<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Particules - Gravit√©</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #0d0d12;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        canvas {
            display: block;
            cursor: crosshair;
        }

        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #e8e8ea;
            background: rgba(15, 15, 20, 0.9);
            padding: 18px 20px;
            border-radius: 12px;
            font-size: 13px;
            z-index: 10;
            border: 1px solid rgba(140, 160, 180, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
        }

        .controls h3 {
            margin-bottom: 12px;
            color: #8ca0b4;
            font-size: 15px;
            font-weight: 600;
            letter-spacing: 0.5px;
        }

        .controls p {
            margin: 6px 0;
            opacity: 0.9;
            color: #b0b8c0;
            font-size: 12px;
        }

        #count {
            color: #8ca0b4;
            font-weight: bold;
        }
        
        .type-counts {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(140, 160, 180, 0.15);
            font-size: 11px;
        }
        
        .type-counts span {
            display: block;
            margin: 4px 0;
        }
        
        .legend {
            font-size: 10px;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(140, 160, 180, 0.15);
            color: #707880;
            line-height: 1.4;
        }
    </style>
</head>
<body>
    <div class="controls">
        <h3>‚öõÔ∏è SYST√àME GRAVITATIONNEL</h3>
        <p>üñ±Ô∏è Mouvement souris: R√©pulsion</p>
        <p>üí• Clic: Onde de choc + Explosion</p>
        <p>üé° Molette: Ajuster quantit√©</p>
        <p>üìä Total: <span id="count">400</span></p>
        <div class="type-counts">
            <span style="color: #5a8aa8;">‚óâ Type A: <span id="blue">0</span></span>
            <span style="color: #6a8080;">‚óâ Type B: <span id="green">0</span></span>
            <span style="color: #7a7a8a;">‚óâ Type C: <span id="red">0</span></span>
        </div>
        <div class="legend">
            üåå Attraction gravitationnelle active<br>
            Transformation par proximit√©:<br>
            A + B ‚Üí A devient B<br>
            B + C ‚Üí B devient C<br>
            C + A ‚Üí C devient A
        </div>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { alpha: false, desynchronized: true });

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        let particlesArray = [];
        let explosionParticles = [];
        let shockwaves = [];
        let maxParticles = 400;
        let time = 0;
        
        const gridSize = 50;

        const mouse = {
            x: null,
            y: null,
            radius: 180,
            activeRadius: 0
        };

        const flockingParams = {
            perceptionRadius: 90,
            separationDistance: 30,
            cohesionForce: 0.008,
            alignmentForce: 0.06,
            separationForce: 0.08,      // Augment√© pour √©quilibrer la gravit√©
            maxSpeed: 2.5,
            maxForce: 0.12,
            connectionDistance: 100,
            gravityStrength: 0.15,       // Force d'attraction gravitationnelle
            gravityMinDist: 20,          // Distance minimale pour √©viter forces infinies
            gravityMaxDist: 150          // Distance maximale d'attraction
        };

        const TYPES = { A: 0, B: 1, C: 2 };
        
        const TYPE_COLORS = {
            [TYPES.A]: { r: 90, g: 138, b: 168, name: 'Cyan Steel' },
            [TYPES.B]: { r: 106, g: 128, b: 128, name: 'Teal Mist' },
            [TYPES.C]: { r: 122, g: 122, b: 138, name: 'Silver Slate' }
        };

        class Shockwave {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 0;
                this.maxRadius = 300;
                this.life = 1.0;
                this.speed = 15;
            }
            
            update() {
                this.radius += this.speed;
                this.life -= 0.02;
                this.speed *= 0.95;
            }
            
            draw() {
                if (this.life <= 0) return;
                
                ctx.strokeStyle = `rgba(140, 160, 180, ${this.life * 0.3})`;
                ctx.lineWidth = 2 * this.life;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.strokeStyle = `rgba(140, 160, 180, ${this.life * 0.15})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius + 10, 0, Math.PI * 2);
                ctx.stroke();
            }
        }

        class Particle {
            constructor(x, y, isExplosion = false, type = null) {
                this.x = x || Math.random() * canvas.width;
                this.y = y || Math.random() * canvas.height;
                this.size = Math.random() * 1.2 + 0.5;
                this.mass = this.size; // Masse proportionnelle √† la taille

                this.type = type !== null ? type : Math.floor(Math.random() * 3);
                this.color = TYPE_COLORS[this.type];
                
                this.jitterSpeed = Math.random() * 0.08 + 0.04;
                this.jitterAmount = Math.random() * 0.4 + 0.15;
                this.jitterOffset = Math.random() * Math.PI * 2;
                
                this.flickerSpeed = Math.random() * 0.015 + 0.008;
                this.flickerOffset = Math.random() * Math.PI * 2;
                this.flickerIntensity = Math.random() * 0.5 + 0.4;
                this.hasGlow = Math.random() > 0.4;
                
                this.orbitRadius = Math.random() * 0.4 + 0.1;
                this.orbitSpeed = (Math.random() - 0.5) * 0.04;
                this.orbitAngle = Math.random() * Math.PI * 2;

                if (isExplosion) {
                    this.velocityX = (Math.random() - 0.5) * 18;
                    this.velocityY = (Math.random() - 0.5) * 18;
                    this.life = 1.0;
                    this.decay = Math.random() * 0.012 + 0.008;
                } else {
                    const angle = Math.random() * Math.PI * 2;
                    this.velocityX = Math.cos(angle) * Math.random() * 2.5;
                    this.velocityY = Math.sin(angle) * Math.random() * 2.5;
                    this.life = -1;
                }

                this.accelerationX = 0;
                this.accelerationY = 0;
                this.baseOpacity = Math.random() * 0.4 + 0.6;
                this.speedVariation = Math.random() * 0.4 + 0.8;
                this.transformCooldown = 0;
                
                this.trail = [];
                this.maxTrailLength = isExplosion ? 8 : 0;
            }

            draw() {
                const alpha = this.life > 0 ? this.life * this.baseOpacity : this.baseOpacity;
                
                const flickerValue = Math.sin(time * this.flickerSpeed + this.flickerOffset) * this.flickerIntensity;
                const brightnessMultiplier = 1 + flickerValue * 0.4;
                
                const r = Math.min(255, Math.floor(this.color.r * brightnessMultiplier));
                const g = Math.min(255, Math.floor(this.color.g * brightnessMultiplier));
                const b = Math.min(255, Math.floor(this.color.b * brightnessMultiplier));
                
                const jitterX = Math.cos(time * this.jitterSpeed + this.jitterOffset) * this.jitterAmount;
                const jitterY = Math.sin(time * this.jitterSpeed * 1.3 + this.jitterOffset) * this.jitterAmount;
                
                const orbitX = Math.cos(this.orbitAngle) * this.orbitRadius;
                const orbitY = Math.sin(this.orbitAngle) * this.orbitRadius;
                
                const drawX = this.x + jitterX + orbitX;
                const drawY = this.y + jitterY + orbitY;
                
                if (this.trail.length > 0) {
                    for (let i = 0; i < this.trail.length - 1; i++) {
                        const trailAlpha = (i / this.trail.length) * alpha * 0.4;
                        ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${trailAlpha})`;
                        ctx.lineWidth = this.size * 0.6;
                        ctx.beginPath();
                        ctx.moveTo(this.trail[i].x, this.trail[i].y);
                        ctx.lineTo(this.trail[i + 1].x, this.trail[i + 1].y);
                        ctx.stroke();
                    }
                }
                
                if (this.hasGlow) {
                    const glowSize = this.size * (4 + flickerValue * 3);
                    const glowAlpha = alpha * 0.12 * (flickerValue + 0.8);
                    
                    const gradient = ctx.createRadialGradient(drawX, drawY, 0, drawX, drawY, glowSize);
                    gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${glowAlpha * 0.8})`);
                    gradient.addColorStop(0.5, `rgba(${r}, ${g}, ${b}, ${glowAlpha * 0.4})`);
                    gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(drawX, drawY, glowSize, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
                ctx.beginPath();
                ctx.arc(drawX, drawY, this.size, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = `rgba(${Math.min(255, r + 30)}, ${Math.min(255, g + 30)}, ${Math.min(255, b + 30)}, ${alpha * 0.6})`;
                ctx.lineWidth = 0.5;
                ctx.stroke();
                
                if (flickerValue > 0.3) {
                    const highlightAlpha = alpha * (flickerValue - 0.3) * 2.5;
                    ctx.fillStyle = `rgba(220, 230, 240, ${highlightAlpha})`;
                    ctx.beginPath();
                    ctx.arc(drawX - this.size * 0.25, drawY - this.size * 0.25, this.size * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            checkTransformations(particles) {
                if (this.transformCooldown > 0) {
                    this.transformCooldown--;
                    return;
                }
                
                for (let other of particles) {
                    if (other === this || other.type === this.type) continue;
                    
                    let dx = this.x - other.x;
                    let dy = this.y - other.y;
                    let distSq = dx * dx + dy * dy;
                    
                    const transformDistSq = flockingParams.connectionDistance * flockingParams.connectionDistance;
                    
                    if (distSq < transformDistSq) {
                        if (this.type === TYPES.A && other.type === TYPES.B) {
                            this.type = TYPES.B;
                            this.color = TYPE_COLORS[TYPES.B];
                            this.transformCooldown = 25;
                            break;
                        }
                        else if (this.type === TYPES.B && other.type === TYPES.C) {
                            this.type = TYPES.C;
                            this.color = TYPE_COLORS[TYPES.C];
                            this.transformCooldown = 25;
                            break;
                        }
                        else if (this.type === TYPES.C && other.type === TYPES.A) {
                            this.type = TYPES.A;
                            this.color = TYPE_COLORS[TYPES.A];
                            this.transformCooldown = 25;
                            break;
                        }
                    }
                }
            }

            // NOUVELLE FONCTION: Attraction gravitationnelle
            gravity(neighbors) {
                let gravityX = 0;
                let gravityY = 0;
                
                const minDistSq = flockingParams.gravityMinDist * flockingParams.gravityMinDist;
                const maxDistSq = flockingParams.gravityMaxDist * flockingParams.gravityMaxDist;
                
                for (let other of neighbors) {
                    if (other === this) continue;
                    
                    let dx = other.x - this.x;
                    let dy = other.y - this.y;
                    let distSq = dx * dx + dy * dy;
                    
                    // Appliquer gravit√© seulement dans la plage d√©finie
                    if (distSq > minDistSq && distSq < maxDistSq) {
                        let dist = Math.sqrt(distSq);
                        
                        // Force gravitationnelle: F = G * m1 * m2 / d¬≤
                        // Simplifi√©e: force proportionnelle aux masses et inversement proportionnelle √† distance
                        let force = (flockingParams.gravityStrength * this.mass * other.mass) / distSq;
                        
                        // Limiter la force maximale
                        force = Math.min(force, 0.5);
                        
                        // Direction normalis√©e
                        gravityX += (dx / dist) * force;
                        gravityY += (dy / dist) * force;
                    }
                }
                
                return { x: gravityX, y: gravityY };
            }

            cohesion(neighbors) {
                if (neighbors.length === 0) return { x: 0, y: 0 };
                let centerX = 0, centerY = 0;
                for (let neighbor of neighbors) {
                    centerX += neighbor.x;
                    centerY += neighbor.y;
                }
                centerX /= neighbors.length;
                centerY /= neighbors.length;
                let steerX = centerX - this.x;
                let steerY = centerY - this.y;
                const mag = Math.sqrt(steerX * steerX + steerY * steerY);
                if (mag > 0) {
                    steerX = (steerX / mag) * flockingParams.cohesionForce;
                    steerY = (steerY / mag) * flockingParams.cohesionForce;
                }
                return { x: steerX, y: steerY };
            }

            alignment(neighbors) {
                if (neighbors.length === 0) return { x: 0, y: 0 };
                let avgVelX = 0, avgVelY = 0;
                for (let neighbor of neighbors) {
                    avgVelX += neighbor.velocityX;
                    avgVelY += neighbor.velocityY;
                }
                avgVelX /= neighbors.length;
                avgVelY /= neighbors.length;
                let steerX = avgVelX - this.velocityX;
                let steerY = avgVelY - this.velocityY;
                const mag = Math.sqrt(steerX * steerX + steerY * steerY);
                if (mag > flockingParams.maxForce) {
                    steerX = (steerX / mag) * flockingParams.maxForce;
                    steerY = (steerY / mag) * flockingParams.maxForce;
                }
                return { x: steerX * flockingParams.alignmentForce, y: steerY * flockingParams.alignmentForce };
            }

            separation(neighbors) {
                if (neighbors.length === 0) return { x: 0, y: 0 };
                let steerX = 0, steerY = 0, count = 0;
                for (let neighbor of neighbors) {
                    let dx = this.x - neighbor.x;
                    let dy = this.y - neighbor.y;
                    let distSq = dx * dx + dy * dy;
                    if (distSq > 0 && distSq < flockingParams.separationDistance * flockingParams.separationDistance) {
                        let dist = Math.sqrt(distSq);
                        steerX += dx / dist;
                        steerY += dy / dist;
                        count++;
                    }
                }
                if (count > 0) {
                    steerX /= count;
                    steerY /= count;
                    const mag = Math.sqrt(steerX * steerX + steerY * steerY);
                    if (mag > 0) {
                        steerX = (steerX / mag) * flockingParams.separationForce;
                        steerY = (steerY / mag) * flockingParams.separationForce;
                    }
                }
                return { x: steerX, y: steerY };
            }

            flock(particles) {
                let neighbors = [];
                for (let other of particles) {
                    if (other === this) continue;
                    let dx = this.x - other.x;
                    let dy = this.y - other.y;
                    let distSq = dx * dx + dy * dy;
                    if (distSq < flockingParams.perceptionRadius * flockingParams.perceptionRadius) {
                        neighbors.push(other);
                    }
                }
                
                // Appliquer toutes les forces incluant la gravit√©
                let cohesion = this.cohesion(neighbors);
                let alignment = this.alignment(neighbors);
                let separation = this.separation(neighbors);
                let gravityForce = this.gravity(particles); // Gravit√© sur toutes les particules
                
                this.accelerationX += cohesion.x + alignment.x + separation.x + gravityForce.x;
                this.accelerationY += cohesion.y + alignment.y + separation.y + gravityForce.y;
                this.accelerationX += (Math.random() - 0.5) * 0.015;
                this.accelerationY += (Math.random() - 0.5) * 0.015;
            }

            update(particles) {
                if (this.maxTrailLength > 0) {
                    this.trail.push({ x: this.x, y: this.y });
                    if (this.trail.length > this.maxTrailLength) {
                        this.trail.shift();
                    }
                }
                
                this.accelerationX = 0;
                this.accelerationY = 0;
                
                if (this.life < 0) {
                    this.flock(particles);
                    this.checkTransformations(particles);
                }

                if (mouse.x != null && mouse.y != null) {
                    let dx = mouse.x - this.x;
                    let dy = mouse.y - this.y;
                    let distSq = dx * dx + dy * dy;
                    let maxDistSq = mouse.radius * mouse.radius;

                    if (distSq < maxDistSq && distSq > 0) {
                        let dist = Math.sqrt(distSq);
                        let force = (mouse.radius - dist) / mouse.radius;
                        this.accelerationX -= (dx / dist) * force * 0.6;
                        this.accelerationY -= (dy / dist) * force * 0.6;
                    }
                }

                this.velocityX += this.accelerationX;
                this.velocityY += this.accelerationY;
                
                let adjustedMaxSpeed = flockingParams.maxSpeed * this.speedVariation;
                let speed = Math.sqrt(this.velocityX * this.velocityX + this.velocityY * this.velocityY);
                if (speed > adjustedMaxSpeed) {
                    this.velocityX = (this.velocityX / speed) * adjustedMaxSpeed;
                    this.velocityY = (this.velocityY / speed) * adjustedMaxSpeed;
                }
                
                if (this.life > 0) {
                    this.life -= this.decay;
                    this.velocityX *= 0.97;
                    this.velocityY *= 0.97;
                }

                this.x += this.velocityX;
                this.y += this.velocityY;
                this.orbitAngle += this.orbitSpeed;

                if (this.x < 0) this.x = canvas.width;
                if (this.x > canvas.width) this.x = 0;
                if (this.y < 0) this.y = canvas.height;
                if (this.y > canvas.height) this.y = 0;
            }
        }

        function drawGrid() {
            ctx.strokeStyle = 'rgba(80, 90, 100, 0.08)';
            ctx.lineWidth = 0.5;
            
            for (let x = 0; x < canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            for (let y = 0; y < canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }
        
        function drawMouseInfluence() {
            if (mouse.x == null || mouse.y == null) return;
            
            mouse.activeRadius = mouse.activeRadius * 0.9 + mouse.radius * 0.1;
            
            ctx.strokeStyle = `rgba(140, 160, 180, 0.15)`;
            ctx.lineWidth = 1.5;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.arc(mouse.x, mouse.y, mouse.activeRadius, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
            
            ctx.fillStyle = 'rgba(140, 160, 180, 0.3)';
            ctx.beginPath();
            ctx.arc(mouse.x, mouse.y, 3, 0, Math.PI * 2);
            ctx.fill();
        }

        function init() {
            particlesArray = [];
            
            const cols = Math.ceil(Math.sqrt(maxParticles * (canvas.width / canvas.height)));
            const rows = Math.ceil(maxParticles / cols);
            
            const marginX = 100;
            const marginY = 100;
            const spacingX = (canvas.width - 2 * marginX) / (cols - 1);
            const spacingY = (canvas.height - 2 * marginY) / (rows - 1);
            
            let index = 0;
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    if (index >= maxParticles) break;
                    
                    const x = marginX + col * spacingX;
                    const y = marginY + row * spacingY;
                    
                    particlesArray.push(new Particle(x, y, false, null));
                    index++;
                }
                if (index >= maxParticles) break;
            }
            
            updateCount();
        }

        function updateCount() {
            let counts = [0, 0, 0];
            for (let p of particlesArray) counts[p.type]++;
            document.getElementById('count').textContent = particlesArray.length;
            document.getElementById('blue').textContent = counts[0];
            document.getElementById('green').textContent = counts[1];
            document.getElementById('red').textContent = counts[2];
        }

        function animate() {
            time += 0.016;
            
            ctx.fillStyle = '#0d0d12';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            drawGrid();

            const drawConnections = particlesArray.length < 800;
            const maxConnections = particlesArray.length > 600 ? 150 : 300;
            let connectionCount = 0;

            if (drawConnections) {
                for (let i = 0; i < particlesArray.length && connectionCount < maxConnections; i++) {
                    if (particlesArray.length > 700 && i % 2 === 0) continue;

                    for (let j = i + 1; j < particlesArray.length && connectionCount < maxConnections; j++) {
                        if (particlesArray.length > 700 && j % 2 === 0) continue;

                        let dx = particlesArray[i].x - particlesArray[j].x;
                        let dy = particlesArray[i].y - particlesArray[j].y;
                        let distSq = dx * dx + dy * dy;

                        if (distSq < flockingParams.connectionDistance * flockingParams.connectionDistance) {
                            connectionCount++;
                            let distance = Math.sqrt(distSq);

                            const baseOpacity = 0.5;
                            const distanceFactor = 1 - (distance / flockingParams.connectionDistance);
                            const opacity = baseOpacity * Math.pow(distanceFactor, 0.7);

                            const p1 = particlesArray[i];
                            const p2 = particlesArray[j];
                            const avgR = (p1.color.r + p2.color.r) / 2;
                            const avgG = (p1.color.g + p2.color.g) / 2;
                            const avgB = (p1.color.b + p2.color.b) / 2;

                            ctx.strokeStyle = `rgba(${avgR}, ${avgG}, ${avgB}, ${opacity})`;
                            ctx.lineWidth = 0.8;
                            ctx.beginPath();
                            ctx.moveTo(particlesArray[i].x, particlesArray[i].y);
                            ctx.lineTo(particlesArray[j].x, particlesArray[j].y);
                            ctx.stroke();
                        }
                    }
                }
            }

            for (let i = 0; i < particlesArray.length; i++) {
                particlesArray[i].update(particlesArray);
                particlesArray[i].draw();
            }

            for (let i = explosionParticles.length - 1; i >= 0; i--) {
                explosionParticles[i].update([]);
                if (explosionParticles[i].life <= 0) {
                    explosionParticles.splice(i, 1);
                } else {
                    explosionParticles[i].draw();
                }
            }
            
            for (let i = shockwaves.length - 1; i >= 0; i--) {
                shockwaves[i].update();
                if (shockwaves[i].life <= 0) {
                    shockwaves.splice(i, 1);
                } else {
                    shockwaves[i].draw();
                }
            }
            
            drawMouseInfluence();
            
            if (Math.floor(time * 60) % 30 === 0) {
                updateCount();
            }

            requestAnimationFrame(animate);
        }

        canvas.addEventListener('mousemove', function(event) {
            mouse.x = event.x;
            mouse.y = event.y;
        });

        canvas.addEventListener('mouseleave', function() {
            mouse.x = null;
            mouse.y = null;
        });

        canvas.addEventListener('click', function(event) {
            shockwaves.push(new Shockwave(event.x, event.y));
            
            const explosionSize = particlesArray.length > 600 ? 30 : 50;
            const randomType = Math.floor(Math.random() * 3);
            for (let i = 0; i < explosionSize; i++) {
                explosionParticles.push(new Particle(event.x, event.y, true, randomType));
            }
        });

        canvas.addEventListener('wheel', function(event) {
            event.preventDefault();
            const step = particlesArray.length > 500 ? 40 : 25;
            if (event.deltaY < 0) {
                if (particlesArray.length < 1200) {
                    for (let i = 0; i < step; i++) {
                        particlesArray.push(new Particle());
                    }
                }
            } else {
                if (particlesArray.length > step) {
                    particlesArray.splice(0, step);
                }
            }
            maxParticles = particlesArray.length;
            updateCount();
        }, { passive: false });

        window.addEventListener('resize', function() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            init();
        });

        init();
        animate();
    </script>
</body>
</html>
